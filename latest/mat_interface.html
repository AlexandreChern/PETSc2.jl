<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mat Interface · Petsc2.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Petsc2.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">PETSc2.jl Documentation</a></li><li><a class="toctext" href="build.html">Build System</a></li><li><a class="toctext" href="init.html">Initialization and Finalization</a></li><li><a class="toctext" href="vec.html">Vec Documentation</a></li><li><a class="toctext" href="vec_interface.html">Vec Interface</a></li><li><a class="toctext" href="mat.html">Mat Documentation</a></li><li class="current"><a class="toctext" href="mat_interface.html">Mat Interface</a><ul class="internal"></ul></li><li><a class="toctext" href="constants.html">Constants</a></li><li><a class="toctext" href="ksp.html">KSP Documentation</a></li><li><a class="toctext" href="pc.html">PC Documentation</a></li><li><a class="toctext" href="options.html">Options Documentation</a></li><li><a class="toctext" href="error.html">Error Handling Documentation</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="mat_interface.html">Mat Interface</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/master/docs/src/mat_interface.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Mat Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Mat-Interface-1" href="#Mat-Interface-1">Mat Interface</a></h1><p>This page describes an interface that is efficiently implemented for both <code>Array</code>, <code>SparseMatrixCSC</code>, and <code>Petscmat</code>.  In some cases, <code>Base</code> functions are extended with new methods, in other cases new functions are defined for the supported matrix types.  Using these functions allows some amount of generic programming.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.PetscMat-Tuple{Integer,Integer,Any,MPI.Comm}" href="#PETSc2.PetscMat-Tuple{Integer,Integer,Any,MPI.Comm}"><code>PETSc2.PetscMat</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Constructor</p><p><strong>Inputs</strong></p><ul><li><p>mglobal: first dimension global size (or PETSC_DECIDE)</p></li><li><p>nglobal: second dimension global size (or PETSC_DECIDE)</p></li><li><p>format: matrix format</p></li><li><p>comm: MPI communicator</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p>mlocal: first dimension local size (or PETSC_DECIDE)</p></li><li><p>nlocal: second dimension local size (or PETSC_DECIDE)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L12-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.PetscDestroy-Tuple{AbstractArray{T,2} where T}" href="#PETSc2.PetscDestroy-Tuple{AbstractArray{T,2} where T}"><code>PETSc2.PetscDestroy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>PetscDestroy for AbstractMatrix.  No-op</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L51-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.PetscView" href="#PETSc2.PetscView"><code>PETSc2.PetscView</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Print a non-Petsc matrix to a given IO (a Julia IO, not a Petsc IO)</p><p><strong>Inputs</strong></p><ul><li><p>A: the matrix</p></li><li><p>f: an IO, default STDOUT</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L262-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.assembly_begin-Tuple{PETSc2.PetscMat,Integer}" href="#PETSc2.assembly_begin-Tuple{PETSc2.PetscMat,Integer}"><code>PETSc2.assembly_begin</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Begin matrix assembly for <code>PetscMat</code>.  No-op for Julia matrices</p><p><strong>Inputs</strong></p><ul><li><p>mat: AbstractMatrix</p></li><li><p>flag: type of matrix assembly (see <a href="mat.html#PETSc2.MatAssemblyBegin-Tuple{PETSc2.PetscMat,Integer}"><code>MatAssemblyBegin</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L228-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.assembly_end-Tuple{PETSc2.PetscMat,Integer}" href="#PETSc2.assembly_end-Tuple{PETSc2.PetscMat,Integer}"><code>PETSc2.assembly_end</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Counterpart of <a href="mat_interface.html#PETSc2.assembly_end-Tuple{PETSc2.PetscMat,Integer}"><code>assembly_end</code></a></p><p><strong>Inputs</strong></p><ul><li><p>mat: AbstractMatrix</p></li><li><p>flg: type of matrix assembly</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L243-L250">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.diagonal_shift!-Tuple{PETSc2.PetscMat,Number}" href="#PETSc2.diagonal_shift!-Tuple{PETSc2.PetscMat,Number}"><code>PETSc2.diagonal_shift!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Adds the specified value to the diagonal of the matrix</p><p><strong>Inputs</strong></p><ul><li><p>A: the matrix</p></li><li><p>a: the value</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L352-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.fill_zero!-Tuple{PETSc2.PetscMat}" href="#PETSc2.fill_zero!-Tuple{PETSc2.PetscMat}"><code>PETSc2.fill_zero!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Fill the matrix with zeros. The sparsity pattern of the matrix (if applicable)   should be defined before this function is called</p><p><strong>Inputs</strong></p><ul><li><p>A: AbstractMatrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L324-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.get_values1!-Tuple{AbstractArray{T,2} where T,Array{Int32,N} where N,Array{Int32,N} where N,Array}" href="#PETSc2.get_values1!-Tuple{AbstractArray{T,2} where T,Array{Int32,N} where N,Array{Int32,N} where N,Array}"><code>PETSc2.get_values1!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for <code>AbstractMatrix</code></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L213-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.get_values1!-Tuple{PETSc2.PetscMat,Array{Int32,N} where N,Array{Int32,N} where N,Array{Float64,N} where N}" href="#PETSc2.get_values1!-Tuple{PETSc2.PetscMat,Array{Int32,N} where N,Array{Int32,N} where N,Array{Float64,N} where N}"><code>PETSc2.get_values1!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like <a href="mat_interface.html#PETSc2.set_values1!"><code>set_values1!</code></a>, but retrieves values.  See that function for   the meanings of the arguments. Note that Petsc does   not support getting values for the non-local block of the matrix</p><p><strong>Inputs</strong></p><ul><li><p>mat: a matrix, can be a Petsc matrix or a julia matrix</p></li></ul><p><strong>Inputs/Outputs</strong></p><ul><li><p>idxm</p></li><li><p>idxn</p></li><li><p>vals</p></li></ul><p>Aliasing restrictions: idxm and idxn cannot alias</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L171-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.local_indices-Tuple{PETSc2.PetscMat}" href="#PETSc2.local_indices-Tuple{PETSc2.PetscMat}"><code>PETSc2.local_indices</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the rows owned by this process (1-based)</p><p><strong>Inputs</strong></p><ul><li><p>A: a matrix</p></li></ul><p><strong>Outputs</strong></p><ul><li><p>rng: a UnitRange</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L304-L314">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.set_values1!" href="#PETSc2.set_values1!"><code>PETSc2.set_values1!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>1-based indexing for both regular and Pets matrices.   Note that Petsc treats arrays at being row-major, so it is recommened   to set MatSetOption(mat, MAT_ROW_ORIENTED, PETSC_FALSE) before using   this function.</p><p><strong>Inputs</strong></p><ul><li><p>flag: INSERT_VALUES or ADD_VALUES.  Note that the first one       result in non-deterministic behavior in parallel (in the general       case)</p></li><li><p>vals: the values, must be length(idxm) x length(idxn)</p></li></ul><p><strong>Inputs/Outputs</strong></p><ul><li><p>mat: a matrix, can be a Petsc matrix or a julia matrix</p></li><li><p>idxm: the row numbers</p></li><li><p>idxn: the column numbers</p></li></ul><p>Note that idxm and idxn are listed as input/outputs because they may be   modified by this function, however when the function returns they   will have the same values as on entry.  This is needed to accomodate the   fact that Petsc uses 1 based indexing internally.</p><p>This function is optimized for PetscMat and SparseMatrixCSC</p><p>Aliasing restriction: idxm and idxn cannot alias</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L60-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.set_values1!-Union{Tuple{AbstractArray{T,2} where T,Array{Int32,N} where N,Array{Int32,N} where N,Array{T,N} where N,Integer}, Tuple{AbstractArray{T,2} where T,Array{Int32,N} where N,Array{Int32,N} where N,Array{T,N} where N}, Tuple{T}} where T" href="#PETSc2.set_values1!-Union{Tuple{AbstractArray{T,2} where T,Array{Int32,N} where N,Array{Int32,N} where N,Array{T,N} where N,Integer}, Tuple{AbstractArray{T,2} where T,Array{Int32,N} where N,Array{Int32,N} where N,Array{T,N} where N}, Tuple{T}} where T"><code>PETSc2.set_values1!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for AbstractMatrix</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L114-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.set_values1!-Union{Tuple{SparseMatrixCSC,Array{Int32,N} where N,Array{Int32,N} where N,Array{T,N} where N,Integer}, Tuple{SparseMatrixCSC,Array{Int32,N} where N,Array{Int32,N} where N,Array{T,N} where N}, Tuple{T}} where T" href="#PETSc2.set_values1!-Union{Tuple{SparseMatrixCSC,Array{Int32,N} where N,Array{Int32,N} where N,Array{T,N} where N,Integer}, Tuple{SparseMatrixCSC,Array{Int32,N} where N,Array{Int32,N} where N,Array{T,N} where N}, Tuple{T}} where T"><code>PETSc2.set_values1!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for <code>SparseMatrixCSC</code></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L138-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.size_global-Tuple{PETSc2.PetscMat}" href="#PETSc2.size_global-Tuple{PETSc2.PetscMat}"><code>PETSc2.size_global</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Global size of matrix, same as size_local() for serial matrices</p><p><strong>Inputs</strong></p><ul><li><p>A: AbstractMatrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L289-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PETSc2.size_local-Tuple{PETSc2.PetscMat}" href="#PETSc2.size_local-Tuple{PETSc2.PetscMat}"><code>PETSc2.size_local</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Size of local part of matrix</p><p><strong>Inputs</strong></p><ul><li><p>A: AbstractMatrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L274-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.A_mul_B!-Tuple{PETSc2.PetscVec,PETSc2.PetscMat,PETSc2.PetscVec}" href="#Base.LinAlg.A_mul_B!-Tuple{PETSc2.PetscVec,PETSc2.PetscMat,PETSc2.PetscVec}"><code>Base.LinAlg.A_mul_B!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes b = A*x</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L399-L401">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.At_mul_B!-Tuple{PETSc2.PetscVec,PETSc2.PetscMat,PETSc2.PetscVec}" href="#Base.LinAlg.At_mul_B!-Tuple{PETSc2.PetscVec,PETSc2.PetscMat,PETSc2.PetscVec}"><code>Base.LinAlg.At_mul_B!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes b = A.&#39;*x</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L407-L409">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm-Tuple{PETSc2.PetscMat,Real}" href="#Base.LinAlg.norm-Tuple{PETSc2.PetscMat,Real}"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Norm for Petsc matrices, 1, 2, and infinity norms supported</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L376-L378">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.scale!-Tuple{PETSc2.PetscMat,Number}" href="#Base.LinAlg.scale!-Tuple{PETSc2.PetscMat,Number}"><code>Base.LinAlg.scale!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>scale! for Petsc matrix</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L345-L347">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.vecnorm-Tuple{PETSc2.PetscMat}" href="#Base.LinAlg.vecnorm-Tuple{PETSc2.PetscMat}"><code>Base.LinAlg.vecnorm</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Frobenius norm, consistent with Julias interface</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PETSc2.jl/blob/86a9bd60b1241646f94e4f1f851c211454de98be/src/mat_interface.jl#L390-L392">source</a></section><footer><hr/><a class="previous" href="mat.html"><span class="direction">Previous</span><span class="title">Mat Documentation</span></a><a class="next" href="constants.html"><span class="direction">Next</span><span class="title">Constants</span></a></footer></article></body></html>
